## 1. 视图层目录组织结构

项目的视图文件全部存放在 `src/views/` 目录下。其组织结构遵循 **模块化** 和 **关注点分离** 的原则。

- **顶级目录按模块划分**：每个直接位于 `src/views/` 下的子目录都代表一个独立的功能模块。例如：
  - `system/`: 系统管理模块
  - `monitor/`: 系统监控模块
  - `table/`: 表格示例模块
  - `login/`: 登录页面
  - `welcome/`: 首页
- **视图文件**：每个模块目录下包含实现具体页面功能的 `.vue` 文件。通常，一个复杂的页面会拥有自己的子目录来组织其相关文件。
- **示例**：以 `system` 模块为例，其内部结构如下：
  - `src/views/system/user/`: 用户管理视图
  - `src/views/system/role/`: 角色管理视图
  - `src/views/system/menu/`: 菜单管理视图
  - `src/views/system/dept/`: 部门管理视图

这种结构使得功能模块界限清晰，便于团队协作和后期维护。

---

## 2. 单个视图的内部文件组织方式

一个独立的视图（尤其是复杂视图）通常会包含一个自己的目录，内部对代码、逻辑、样式和类型定义进行精细化管理。以 `src/views/system/user/` 为例，其文件组织方式具有代表性：

```
/src/views/system/user/
|-- index.vue         # 视图主入口文件，负责整合模板、逻辑和样式
|-- utils/            # 存放该视图相关的工具、逻辑和配置
|   |-- hook.tsx      # 核心逻辑钩子（Composition API），负责数据处理、表格列定义、事件处理等
|   |-- rule.ts       # 表单验证规则
|   |-- types.ts      # TypeScript 类型定义
|   |-- reset.css     # 针对该视图的特定样式重置或调整
```

**这种组织方式的核心思想是：**

1. **主文件 `index.vue` 保持简洁**：它主要作为视图的“骨架”，负责模板渲染和调用外部逻辑，而不是将所有代码都堆积在一起。

2. **逻辑高度集中在 `hook.tsx`**：这是该模式的精髓。使用 `.tsx` 文件意味着可以在其中利用 JSX 的灵活性来定义复杂的渲染逻辑（例如表格列的自定义渲染）。它通常会导出一个函数（如 `useUser`），该函数返回视图所需的数据（`ref`, `reactive`）和方法。这种方式使得视图的响应式逻辑被完全抽离，极大地增强了代码的可读性和可维护性。

3. 类型、规则分离

   ：

   - `types.ts`: 为视图中使用的数据结构（如表单模型、表格行数据）提供强类型支持。
   - `rule.ts`: 专门存放 `element-plus` 或其他表单库所需的校验规则，使校验逻辑与业务逻辑解耦。

4. **样式隔离**：除了在 `.vue` 文件中使用 `<style scoped>` 外，对于一些需要覆盖组件库默认样式或定义复杂动画的场景，会使用独立的 `.css` 或 `.scss` 文件。

---

## 3. 视图所需组件分析

项目中的组件可以分为两类：**全局组件** 和 **视图独立组件**。

### 全局/通用组件

这些组件位于 `src/components/` 目录下，经过全局注册或按需引入，可在任何视图中使用。它们提供了项目范围内统一的交互和视觉体验。

- 核心通用组件示例

  ：

  - `RePureTableBar` (`/src/components/RePureTableBar/`): 功能强大的表格工具栏，集成了刷新、列设置、搜索等功能，是项目中表格页面的标配。
  - `ReDialog` (`/src/components/ReDialog/`): 对 `el-dialog` 的二次封装，提供了更便捷的拖拽、全屏等功能。
  - `ReIcon` (`/src/components/ReIcon/`): 统一的图标解决方案，支持 `iconify` 和本地 `svg`。
  - `ReAuth` (`/src/components/ReAuth/`): 权限控制组件，用于按权限动态显示或隐藏页面元素。
  - `ReSegmented` (`/src/components/ReSegmented/`): 自定义的分段控制器，提供了更丰富的样式和交互。

### 视图独立组件

当某个组件的复用范围仅限于单个视图或模块时，它会被定义在所属视图的目录内，通常在 `components/` 子目录下。

- 示例

  ：在

  ```
  welcome
  ```

  (首页) 视图中：

  - `src/views/welcome/components/Bar.vue`: 用于展示柱状图的 ECharts 组件。
  - `src/views/welcome/components/Line.vue`: 用于展示折线图的 ECharts 组件。
  - `src/views/welcome/components/Pie.vue`: 用于展示饼图的 ECharts 组件。

这些图表组件仅在首页使用，因此将它们放在 `welcome` 视图内部可以避免污染全局组件空间，也使得视图的依赖关系更加内聚。

---

## 4. 开发规则与技术规范总结

根据对项目文件的分析，可以总结出以下视图层开发的核心规则和技术规范：

1. **技术栈**：
   - **框架**：Vue 3
   - **开发语言**：TypeScript
   - **视图逻辑**：`<script setup>` 语法糖与 Composition API 是首选。
   - **复杂渲染**：在 `hook.tsx` 中使用 TSX (JSX) 来处理动态性强、逻辑复杂的渲染任务（特别是表格列定义）。
2. **代码风格与规范**：
   - **ESLint 和 Prettier**：项目集成了严格的代码格式化和质量检查工具 (`eslint.config.js`, `.prettierrc.js`)，确保代码风格统一。
   - **Commitlint**：提交信息遵循规范 (`commitlint.config.js`)，便于追溯和生成更新日志。
3. **逻辑分离 (SoC)**：
   - **Composition API (`hook.tsx`)**：这是最重要的规范。视图的业务逻辑、数据请求、响应式状态和方法必须抽离到 `useXXX` 形式的 hook 中。
   - **API 请求分离**：数据接口请求被封装在 `src/api/` 目录下，视图中通过导入相应的 API 函数来调用，而不是直接使用 `axios`。
4. **状态管理**：
   - 使用 **Pinia** (`src/store/`) 进行全局状态管理。每个模块（如 `user`, `settings`）拥有自己的 store。视图应通过 store 获取和修改全局状态，而不是通过 props 或 events 进行深度传递。
5. **路由集成**：
   - 视图与路由的映射关系在 `src/router/modules/` 中定义。每个模块的路由配置是独立的，最终会被整合到主路由中。
   - 路由元信息 (`meta`) 被广泛使用，用于定义页面标题、图标、权限、缓存策略等。
6. **样式方案**：
   - **Tailwind CSS** 和 **SCSS** 结合使用。`tailwind.css` 用于快速构建原子化的样式，而 `scss` (`.scss` 文件) 用于编写更复杂的、结构化的样式规则以及覆盖UI库样式。
   - 组件级别样式优先使用 `<style scoped>` 来避免全局样式污染。

### 核心组件、使用规则及应用场景分析

#### 1. RePureTableBar - 高级表格工具栏

- **功能描述**: 一个功能强大的、与 `pure-table` 配套使用的高级工具栏。它集成了标题、操作按钮、列动态显隐（列设置）、密度调整和刷新功能，极大地简化了表格页面的开发。

- **使用规则**: 该组件通过属性（props）和事件（events）与父组件进行交互。

  - `title` (prop): `String` 类型，设置工具栏左侧的标题。
  - `buttons` (prop): `Array<VNode | Component>` 类型，用于在工具栏右侧插入自定义按钮，如“新增”、“导出”等。
  - `columns` (prop): `Array<TableColumnList>` 类型，这是 **必需** 的属性，接收 `pure-table` 的列配置数组，用于“列设置”功能。

  - `adaptive` (prop): `boolean` 类型，是否开启表格高度自适应，默认 `true`。

  - `refresh` (event): 当用户点击刷新按钮时触发，父组件应监听此事件来重新加载表格数据。
  - `onUpdate:columns` (event): 当用户在“列设置”中改变了列的显隐或顺序时触发。

- **应用场景**: 所有需要展示数据的表格页面。几乎是项目中每个CURD（增删改查）页面的标配组件，放在表格的上方，提供统一的操作体验。 **示例路径**: `src/views/system/user/index.vue`

---

#### 2. ReDialog - 可拖拽弹窗

- **功能描述**: 基于 `Element-Plus` 的 `el-dialog` 进行的二次封装。它在保留 `el-dialog` 所有功能的基础上，增加了**可拖拽**、**可全屏**、**自适应高度**等实用特性。
- **使用规则**:
  - 继承 `el-dialog` 的所有 `props`，如 `v-model:visible`, `title` 等。
  - `draggable` (prop): `Boolean` 类型，设置为 `true` 即可开启拖拽功能。
  - 通过 `slot` 插入内容和底部按钮，与 `el-dialog` 用法一致。
- **应用场景**: 任何需要弹出表单、详情、确认信息等场景。例如，在用户管理页面点击“新增”或“编辑”按钮时，弹出的表单就可以使用 `ReDialog`。 **示例路径**: `src/views/system/user/utils/hook.tsx` (在 hook 中通过 `addDialog` 等方法控制)

---

#### 3. ReIcon - 统一图标组件

- **功能描述**: 一个强大的图标解决方案，无缝集成了 `Iconify` (在线和离线) 和本地 `SVG` 图标。

- **使用规则**:

  - ```
    icon
    ```

    (prop):

    ```
    String
    ```

    类型，指定要渲染的图标名称。

    - `Iconify` 图标格式: `collection-name:icon-name` (例如: `ep:search`)。
    - 本地 `SVG` 图标格式: `svg-name` (例如: `logo`)。

  - `color` (prop): `String` 类型，设置图标颜色。

  - `size` (prop): `String | Number` 类型，设置图标大小。

- **应用场景**: 贯穿整个项目，用于菜单、按钮、提示信息等任何需要图标的地方。它统一了项目的图标来源和使用方式，便于管理和替换。 **示例路径**: 几乎所有 `.vue` 和 `.tsx` 文件中都有使用。

---

#### 4. ReAuth - 权限控制组件

- **功能描述**: 一个用于按钮级别权限控制的组件。它会根据传入的权限标识和当前用户的权限列表来决定是否渲染其包裹的子元素。
- **使用规则**:
  - `value` (prop): `String` 或 `Array<String>` 类型，定义所需的权限标识。
  - 组件会包裹需要进行权限判断的元素。如果用户拥有 `value` 定义的权限，则子元素正常显示；否则不显示。
- **应用场景**: 在页面中对按钮或特定区域进行精细化的权限控制。例如，用户列表页的“新增”、“删除”按钮，只有具备相应权限（如 `system:user:add`, `system:user:delete`）的用户才能看到。 **示例路径**: `src/views/system/user/utils/hook.tsx` (在表格操作列的按钮上使用)

---

#### 5. ReCropper - 图片裁剪组件

- **功能描述**: 一个高性能的图片裁剪组件，支持矩形和圆形裁剪，提供丰富的配置项和实时预览功能。
- **使用规则**:
  - `imgSrc` (prop): `String` 类型，要裁剪的原始图片地址。
  - `circled` (prop): `Boolean` 类型，是否为圆形裁剪。
  - `quality` (prop): `Number` 类型，输出图片的质量 (0到1之间)。
  - `getCroppedBlob` (event): 裁剪完成后，触发此事件并返回裁剪后的 `Blob` 对象。
  - `getReady` (event): 组件加载完成后触发。
- **应用场景**: 用于用户上传头像、裁剪文章封面等需要对图片进行二次处理的场景。

---

#### 6. ReSeamlessScroll - 无缝滚动组件

- **功能描述**: 一个可以实现内容无缝、平滑滚动的组件，常用于展示通知、榜单等需要循环滚动的列表。
- **使用规则**:
  - `list` (prop): `Array` 类型，需要滚动的列表数据。
  - `isSingle` (prop): `Boolean` 类型，是否是单行滚动。
  - `direction` (prop): `String` 类型，滚动方向，可选值为 `up` (默认) 或 `down`。
  - 通过默认 `slot` 传入列表项的模板。
- **应用场景**:
  - 大屏或首页展示滚动的通知公告。
  - 展示实时更新的数据榜单，如销售龙虎榜。

---

#### 7. ReSegmented - 分段控制器

- **功能描述**: 对 `Element-Plus` 相应组件的封装和样式优化，提供了一种在多个选项中进行切换的UI形式，常用于顶部标签页的模式切换。
- **使用规则**:
  - `options` (prop): `Array` 类型，分段器的选项配置，通常是 `{ label, value, icon }` 的结构。
  - `v-model:value`：双向绑定当前选中的 `value`。
- **应用场景**:
  - 系统设置中切换布局模式（垂直、水平、混合）。
  - 作为内容区域的筛选器，切换不同类型的数据视图。 **示例路径**: `src/layout/components/lay-sidebar/components/TopNav.vue`

---

#### 8. 其他核心组件概览

| 组件名            | 功能描述                                    | 主要应用场景                               |
| ----------------- | ------------------------------------------- | ------------------------------------------ |
| **ReBarcode**     | 生成条形码的组件。                          | 物流、仓储、商品信息展示。                 |
| **ReQrcode**      | 生成二维码的组件，支持logo和颜色定义。      | 分享链接、移动端扫码登录、信息展示。       |
| **ReCountTo**     | 数字滚动动画组件，支持多种缓动效果。        | 数据大屏、统计面板中突出显示关键指标。     |
| **ReFlicker**     | CSS 实现的闪烁特效，用于创建视觉焦点。      | 警告标识、需要特别提醒的元素。             |
| **ReFlop**        | 翻牌器效果的数字展示组件。                  | 数据大屏中实时更新的统计数据。             |
| **ReImageVerify** | 图片滑块验证码组件。                        | 登录、注册等需要人机验证的场景。           |
| **ReSplitPane**   | 可拖拽的分割面板，可水平或垂直分割区域。    | 文件管理器、代码编辑器等多栏布局。         |
| **ReText**        | 文本溢出处理组件，自动处理省略号和tooltip。 | 表格、列表等空间有限的文本展示区域。       |
| **ReTypeit**      | 打字机效果组件，模拟文本输入动画。          | 首页、引导页、个人简介等吸引注意力的场景。 |
| **ReVxeTableBar** | 专为 `vxe-table` 封装的工具栏。             | 使用 `vxe-table` 的页面，提供统一操作。    |
| **ReTreeLine**    | 带连接线的树形组件，增强层级关系的可视化。  | 部门结构、菜单管理等树形数据展示。         |

---

## 四、CRUD 模块开发规范（基于权限分类管理和部门管理）

### 4.1 模块结构标准

每个 CRUD 模块应遵循以下目录结构：

```
src/views/system/[module_name]/
├── index.vue          # 主视图文件
├── form/
│   └── index.vue      # 表单组件
└── utils/
    ├── hook.tsx       # 业务逻辑钩子
    └── types.ts       # 类型定义（可选）
```

### 4.2 主视图文件（index.vue）开发规范

#### 4.2.1 基础结构模板

```vue
<script setup lang="ts">
import { ref } from "vue";
import { use[ModuleName] } from "./utils/hook";
import { PureTableBar } from "@/components/RePureTableBar";
import { useRenderIcon } from "@/components/ReIcon/src/hooks";
// 导入必要的图标
import Delete from "~icons/ep/delete";
import EditPen from "~icons/ep/edit-pen";
import Refresh from "~icons/ep/refresh";
import AddFill from "~icons/ri/add-circle-line";

defineOptions({
  name: "[ModuleName]Management"
});

const formRef = ref();
const tableRef = ref();

// 解构业务逻辑钩子
const {
  form,
  loading,
  columns,
  dataList,
  selectedRows,
  hasSelection,
  handleSelectionChange,
  resetForm,
  onSearch,
  openDialog,
  handleDelete,
  handleBatchDelete
} = use[ModuleName]();

const onFullscreen = () => {
  tableRef.value.setAdaptive();
};
</script>

<template>
  <div class="main">
    <!-- 搜索表单区域 -->
    <el-form
      ref="formRef"
      :inline="true"
      :model="form"
      class="search-form bg-bg_color w-full pl-8 pt-[12px] overflow-auto"
    >
      <!-- 搜索字段 -->
      <el-form-item label="名称：" prop="name">
        <el-input
          v-model="form.name"
          placeholder="请输入名称"
          clearable
          class="!w-[200px]"
        />
      </el-form-item>

      <!-- 操作按钮 -->
      <el-form-item>
        <el-button
          type="primary"
          :icon="useRenderIcon('ri:search-line')"
          :loading="loading"
          @click="onSearch"
        >
          搜索
        </el-button>
        <el-button :icon="useRenderIcon(Refresh)" @click="resetForm">
          重置
        </el-button>
      </el-form-item>
    </el-form>

    <!-- 表格工具栏 -->
    <PureTableBar title="数据列表" :columns="columns" @refresh="onSearch">
      <template #buttons>
        <el-button
          type="primary"
          :icon="useRenderIcon(AddFill)"
          @click="openDialog()"
        >
          新增
        </el-button>
        <el-button
          type="danger"
          :icon="useRenderIcon(Delete)"
          :disabled="!hasSelection"
          @click="handleBatchDelete"
        >
          批量删除
        </el-button>
      </template>

      <template v-slot="{ size, dynamicColumns }">
        <pure-table
          ref="tableRef"
          adaptive
          :adaptiveConfig="{ offsetBottom: 108 }"
          align-whole="center"
          table-layout="auto"
          :loading="loading"
          :size="size"
          :data="dataList"
          :columns="dynamicColumns"
          :pagination="false"
          :paginationSmall="size === 'small'"
          :header-cell-style="{
            background: 'var(--el-fill-color-lighter)',
            color: 'var(--el-text-color-primary)'
          }"
          row-key="id"
          @selection-change="handleSelectionChange"
        >
          <!-- 操作列插槽 -->
          <template #operation="{ row }">
            <el-button
              class="reset-margin"
              link
              type="primary"
              :size="size"
              :icon="useRenderIcon(EditPen)"
              @click="openDialog('编辑', row)"
            >
              修改
            </el-button>
            <el-button
              class="reset-margin"
              link
              type="primary"
              :size="size"
              :icon="useRenderIcon(AddFill)"
              @click="openDialog('新增', null, row)"
            >
              新增
            </el-button>
            <el-popconfirm
              :title="`是否确认删除名称为${row.name}的这条数据`"
              @confirm="handleDelete(row)"
            >
              <template #reference>
                <el-button
                  class="reset-margin"
                  link
                  type="primary"
                  :size="size"
                  :icon="useRenderIcon(Delete)"
                >
                  删除
                </el-button>
              </template>
            </el-popconfirm>
          </template>
        </pure-table>
      </template>
    </PureTableBar>
  </div>
</template>
```

#### 4.2.2 关键要素说明

1. **组件命名**：使用 `defineOptions` 定义组件名称，格式为 `[ModuleName]Management`
2. **引用管理**：统一使用 `formRef` 和 `tableRef` 管理表单和表格引用
3. **业务逻辑分离**：所有业务逻辑通过 `use[ModuleName]()` 钩子管理
4. **图标使用**：统一使用 `useRenderIcon` 渲染图标
5. **操作列**：必须设置 `slot="operation"` 才能显示操作按钮

### 4.3 业务逻辑钩子（utils/hook.tsx）开发规范

#### 4.3.1 基础结构模板

```tsx
import { ref, reactive, computed, h, onMounted } from "vue";
import { ElMessage, ElMessageBox } from "element-plus";
import { formatDateTime } from "@/utils/dateTime";
import { addDialog } from "@/components/ReDialog";
import {
  // API 方法导入
  get[ModuleName]List,
  create[ModuleName],
  update[ModuleName],
  delete[ModuleName],
  batchDelete[ModuleName]s,
  type [ModuleName]Type
} from "@/api/system/[module_api]";
import [ModuleName]Form from "../form/index.vue";

export function use[ModuleName]() {
  // 1. 状态定义
  const form = reactive({
    name: "",
    // 其他搜索字段
  });

  const formRef = ref();
  const dataList = ref<[ModuleName]Type[]>([]);
  const loading = ref(false);
  const selectedRows = ref<[ModuleName]Type[]>([]);

  // 2. 表格列配置
  const columns: TableColumnList = [
    {
      type: "selection",
      width: 55,
      align: "center",
      hide: false
    },
    {
      label: "序号",
      type: "index",
      width: 70,
      hide: false
    },
    // 业务字段列
    {
      label: "名称",
      prop: "name",
      minWidth: 150
    },
    {
      label: "创建时间",
      prop: "created_at",
      width: 180,
      formatter: (row: [ModuleName]Type) => formatDateTime(row.created_at)
    },
    {
      label: "更新时间",
      prop: "updated_at",
      width: 180,
      formatter: (row: [ModuleName]Type) => formatDateTime(row.updated_at)
    },
    {
      label: "操作",
      prop: "operation",
      width: 210,
      fixed: "right",
      slot: "operation" // 必须设置此属性
    }
  ];

  // 3. 计算属性
  const hasSelection = computed(() => selectedRows.value.length > 0);

  // 4. 基础方法
  const resetForm = () => {
    Object.keys(form).forEach(key => {
      form[key] = "";
    });
  };

  const onSearch = async () => {
    try {
      loading.value = true;
      const { data } = await get[ModuleName]List();
      dataList.value = data.items || [];
    } catch (error) {
      console.error("获取列表失败:", error);
      ElMessage.error("获取列表失败");
    } finally {
      loading.value = false;
    }
  };

  const handleSelectionChange = (selection: [ModuleName]Type[]) => {
    selectedRows.value = selection;
  };

  // 5. 对话框操作
  const openDialog = (title = "新增", row?: [ModuleName]Type, parent?: [ModuleName]Type) => {
    addDialog({
      title: `${title}[模块名称]`,
      props: {
        formInline: {
          id: row?.id ?? null,
          parent_id: parent?.id ?? row?.parent_id ?? null,
          // 其他字段
        }
      },
      width: "40%",
      draggable: true,
      fullscreen: false,
      fullscreenIcon: true,
      closeOnClickModal: false,
      contentRenderer: () => h([ModuleName]Form, { ref: formRef }),
      beforeSure: (done, { options }) => {
        const FormRef = formRef.value.getRef();
        const curData = options.props.formInline as [ModuleName]Type;

        FormRef.validate(async valid => {
          if (valid) {
            try {
              if (curData.id) {
                await update[ModuleName](curData.id, curData);
                ElMessage.success("更新成功");
              } else {
                await create[ModuleName](curData);
                ElMessage.success("新增成功");
              }
              done();
              onSearch();
            } catch (error) {
              console.error("操作失败:", error);
            }
          }
        });
      }
    });
  };

  // 6. 删除操作
  const handleDelete = async (row: [ModuleName]Type) => {
    try {
      await delete[ModuleName](row.id);
      ElMessage.success("删除成功");
      onSearch();
    } catch (error) {
      console.error("删除失败:", error);
      ElMessage.error("删除失败");
    }
  };

  const handleBatchDelete = async () => {
    if (selectedRows.value.length === 0) {
      ElMessage.warning("请选择要删除的数据");
      return;
    }

    try {
      await ElMessageBox.confirm(
        `确认删除选中的 ${selectedRows.value.length} 条数据吗？`,
        "批量删除确认",
        {
          type: "warning"
        }
      );

      const ids = selectedRows.value.map(row => row.id);
      await batchDelete[ModuleName]s(ids);
      ElMessage.success("批量删除成功");
      selectedRows.value = [];
      onSearch();
    } catch (error) {
      if (error !== "cancel") {
        console.error("批量删除失败:", error);
        ElMessage.error("批量删除失败");
      }
    }
  };

  // 7. 生命周期
  onMounted(() => {
    onSearch();
  });

  // 8. 返回值
  return {
    form,
    loading,
    columns,
    dataList,
    selectedRows,
    hasSelection,
    handleSelectionChange,
    resetForm,
    onSearch,
    openDialog,
    handleDelete,
    handleBatchDelete
  };
}
```

#### 4.3.2 关键规范说明

1. **状态管理**：使用 `reactive` 管理表单状态，`ref` 管理列表数据
2. **表格列配置**：必须包含 `selection`、`index`、业务字段、时间字段、操作列
3. **操作列配置**：必须设置 `slot: "operation"` 属性
4. **错误处理**：统一使用 `try-catch` 处理异步操作
5. **消息提示**：使用 `ElMessage` 提供用户反馈
6. **对话框管理**：使用 `addDialog` 统一管理弹窗
7. **生命周期**：在 `onMounted` 中初始化数据

### 4.4 表单组件（form/index.vue）开发规范

#### 4.4.1 基础结构模板

```vue
<script setup lang="ts">
import { ref, computed } from "vue";
import { ElMessage } from "element-plus";

interface FormProps {
  formInline: {
    id?: number;
    parent_id?: number;
    name: string;
    // 其他字段
  };
}

interface FormEmits {
  (e: "update:formInline", val: FormProps["formInline"]): void;
}

const props = withDefaults(defineProps<FormProps>(), {
  formInline: () => ({
    id: null,
    parent_id: null,
    name: ""
    // 其他字段默认值
  })
});

const emit = defineEmits<FormEmits>();

const ruleFormRef = ref();
const newFormInline = ref(props.formInline);

// 表单验证规则
const rules = {
  name: [{ required: true, message: "名称为必填项", trigger: "blur" }]
  // 其他验证规则
};

// 计算属性
const formTitle = computed(() => {
  return newFormInline.value.id ? "编辑" : "新增";
});

// 获取表单引用
function getRef() {
  return ruleFormRef.value;
}

// 暴露方法
defineExpose({ getRef });
</script>

<template>
  <el-form
    ref="ruleFormRef"
    :model="newFormInline"
    :rules="rules"
    label-width="100px"
  >
    <el-form-item label="名称" prop="name">
      <el-input
        v-model="newFormInline.name"
        clearable
        placeholder="请输入名称"
      />
    </el-form-item>

    <!-- 其他表单项 -->
  </el-form>
</template>
```

### 4.5 开发检查清单

#### 4.5.1 文件结构检查

- [ ] 目录结构符合标准（index.vue、form/index.vue、utils/hook.tsx）
- [ ] 文件命名规范正确
- [ ] 导入语句完整且有序

#### 4.5.2 主视图文件检查

- [ ] 组件名称使用 `defineOptions` 定义
- [ ] 正确解构业务逻辑钩子
- [ ] 搜索表单结构完整
- [ ] 表格工具栏配置正确
- [ ] 操作列插槽实现完整
- [ ] 图标使用 `useRenderIcon` 渲染

#### 4.5.3 业务逻辑钩子检查

- [ ] 状态定义完整（form、loading、dataList、selectedRows）
- [ ] 表格列配置包含所有必要列
- [ ] 操作列设置了 `slot: "operation"` 属性
- [ ] 基础方法实现完整（resetForm、onSearch、handleSelectionChange）
- [ ] 对话框操作实现完整（openDialog）
- [ ] 删除操作实现完整（handleDelete、handleBatchDelete）
- [ ] 错误处理和用户反馈完善
- [ ] 生命周期钩子正确使用
- [ ] 返回值包含所有必要的状态和方法

#### 4.5.4 表单组件检查

- [ ] Props 和 Emits 类型定义正确
- [ ] 表单验证规则完整
- [ ] 表单引用正确暴露
- [ ] 表单项配置完整

### 4.6 最佳实践建议

1. **代码复用**：新模块可以直接复制现有模块代码，然后修改相关字段和 API 调用
2. **类型安全**：充分利用 TypeScript 类型系统，确保类型安全
3. **错误处理**：统一错误处理模式，提供良好的用户体验
4. **性能优化**：合理使用 `computed` 和 `watch`，避免不必要的重复计算
5. **可维护性**：保持代码结构清晰，注释完善，便于后续维护
6. **测试友好**：保持组件的单一职责，便于单元测试

通过遵循以上规范，可以确保所有 CRUD 模块具有一致的代码风格和结构，提高开发效率和代码质量。
